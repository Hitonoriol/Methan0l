<% "References" :: newl

<% "Basic reference syntax & behavior"
{
	var = 1337
	var2 = "Some text"
	ref = **var

	<% "Initial value: var = " :: var

	ref *= 2
	<% $"Modified `var` via reference: ref = {}, var = {}" ref, var

	/* Reset the Value reference is pointing at */
	ref.reset(var2)
	<% $"Reference now points at `var2`: var2 = {}, ref = {}" var2, ref
}
<% ""

/* References can only be assigned to variables
 * 	or returned from functions explicitly (by using the `**` operator),
 * 	otherwise they get unwrapped and a copy of referenced value is created. */
<% "Reference unwrapping behavior"
{
	var = 123
	ref = **var
	
	a = ref		/* `a` is a copy */
	b = **ref	/* `b` is a reference to `var` */
	
	/* No-arg function with `var` captured by reference,
	 * returns a reference to `var`. */
	foo = f: %var -> **var
	
	/* This returns a copy of `var`, even though `var` inside
	 * 	of the `bar`'s scope is a reference to the outer `var`. */
	bar = f: %var -> var
	
	<% $"Modifying a & b: ++a = {}, ++b = {}, var = {}" ++a, ++b, var
	<% $"Modifying func return values: ++foo() = {}, ++bar() = {}, var = {}" ++foo(), ++bar(), var
}
<% ""

<% "Type-checking a reference"
{
	x = 0.5
	ref = **x

	<% $"Type of `**x`: " typename: ref
	<% $"Is `ref` a reference: {}" is_reference: ref
	<% $"Is `x` a reference: {}" is_reference: x
}