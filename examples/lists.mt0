"Lists" :: newl

/* List definition syntax */
list = $(1, 2, 3, "abc", 0.5)
list_str = {("List: " :: #list)!}
view_lst = {%%(#list_str$() :: newl)}

view_lst

/* List syntax is also used when invoking Units / Functions(TODO) */
unit = {"I am a completely useless unit"!}
%%("Unit says: " :: unit$() :: newl) /* <-- Units don't accept arguments (except for init blocks, see example below & in pseudo_func.mt0),
						so an empty list must be passed in invocation expr */
"Append new element"
list[] = "New element"
view_lst

"Remove element"
list[~2]
view_lst

/* List indexing operator */
%%("Third element: " :: list[2] :: newl)
list[0] = "The first element"
list[5] = -64
view_lst

newl :: "Populating a list in a recursive \"loop\"..."
/* This can be done in a more sane way, but I wanted to demonstrate how recursive calls work in Methan0l */
list_populator = {
	(++i) > max ? -> {"Done populating new list"; new_list!}
	new_list[] = 1.0 / i
	(#list_populator$({i = #i; max = #max; new_list = #new_list}))!
	/* # means global scope lookup, this ^^^ effectively copies the variables
	 * from our current recursive call's scope to the next one's */
}

/* Using pseudo-function syntax for initialization
 * (basically just injecting values into the unit's local scope) (see pseudo_func.mt0) */
ret = list_populator$({i = 0; max = 10; new_list = $()})
"New " :: list_str$({list = #ret})

/* size function */
%%("List size: " :: size$(ret) :: newl)
newl

"Foreach loop"
do $(val, ret) -> {
	"* " :: val
}
""

"Functional foreach"
ret.for_each$(func @(x) { %%(x :: "--") })
""

"Range function -- returns a list w/ Integer elements in specified range:"
%% ("[0; 9] --> " :: range$(10) :: newl)
%% ("[-10; 9] --> " :: range$(-10, 10) :: newl)
%% ("{-25; -20; ...; 25} --> " :: range$(-25, 30, 5) :: newl)