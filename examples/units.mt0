"Units & Scopes" :: newl

/* Unit is an expression block with it's own local visibility scope
 * (in fact, this whole program is a Unit itself)
 
Visibility Scopes:
 * By default, Regular Unit can only access its own local identifiers (defined within its scope, everything else is "global"),
 	while Weak Unit can access its own idfrs & any idfr above its scope up to the first Regular Unit,
 	everything else is considered "global scope".
 * To access a variable from the global scope, use # prefix before the identifier

Return:
 * Units can return values by using the postfix ! operator after the expr
 * There's 2 types of Unit behavior on return:
 	1. Regular Units ( defined as {expr1; expr2; ...} ) stop their own execution and return a value.
 		Then the Unit's parent (if any) resumes its execution.
 	2. Weak Units ( defined as ->{expr1; expr2; ...} ) stop their own execution, return value
 		and cause their parent unit to also stop execution and "carry" the child return value.
 		Nested Weak Units cause each other to stop execution & carry return value until execution reaches a Regular Unit.
 	
 	Possible use cases for type (1) are functions
 		and type (2) Units can be used in conditional operator bodies & loops
 */
calls = 0
unit = {
	local_var = "Blah blah" /* Shouldn't be accesible from the global scope */
	%% "Boom! A Unit has been called! [" :: ++#calls :: "] "
	%% "(my local var: " :: local_var :: ")"
	%% newl
	#calls * 10!
	"Some dead code" /* Execution won't reach this point */
}

/* Parent-less literals are printed out to the stdout followed by a new line */
256
0.111
"String literal"
true
""

/* Execute defined unit, this way the return is discarded */
unit

"Local scope check"
%% "* Unit's local var as seen from global scope (should be nil): " :: local_var :: newl

/* Capturing Unit's return value:
 * Incorrect way:
 *	foo = unit <-- this will just eval the unit into itself
 *	and assign it to the foo, the execution won't happen
 *
 * Correct way:
 */
ret = unit$() /* Will capture the returned value of the unit */
%% "Unit returned: " :: ret :: newl

arg_unit = {x + y!}

/* You can pass a single pseudo-arg Unit (aka init block) as an argument when invoking another Unit,
 * 	its expressions will be evaluated & Data Table will be shared with the invoked Unit */
result = arg_unit$({x = 1.9; y = 42.42})
%% "Result after passing init block: " :: result :: newl

"Weak Unit scope visibility:"
global = "This isn't visible for the Weak Unit below without the # prefix"
{
	var = "Some variable"
	-> {
		local = 123456
		%% "I'm a Weak Unit. I see my local var: \"" :: local
			:: "\" and a var above my scope: \"" :: var :: "\"" :: newl
		%% "I can't see this without # prefix: " :: global :: " | Here it is: `" :: #global :: "`" :: newl
	}
}

nil! /* Return stops current Unit's execution */

<% "This will never be printed"